# Á¨¨‰∏âÈò∂ÊÆµÔºöÊÄßËÉΩ‰ºòÂåñÂíåÁõëÊéßÊñπÊ°à

## Ê∏≤ÊüìÊÄßËÉΩ‰ºòÂåñ

### ÈóÆÈ¢òÂàÜÊûê
ÂΩìÂâç REPL ÁªÑ‰ª∂Âú®ÊØèÊ¨°Áä∂ÊÄÅÊõ¥Êñ∞Êó∂ÈÉΩ‰ºöÈáçÊñ∞Ê∏≤ÊüìÊï¥‰∏™Ê∂àÊÅØÂéÜÂè≤ÔºåËøôÂú®ÈïøÂØπËØù‰∏≠‰ºöÂØºËá¥ÊÄßËÉΩÈóÆÈ¢ò„ÄÇ

### ‰ºòÂåñÁ≠ñÁï•

#### 1. Ê∂àÊÅØËôöÊãüÂåñ
```tsx
// components/VirtualizedMessageList.tsx
import { FixedSizeList as List } from 'react-window'
import { useMemo } from 'react'

interface VirtualizedMessageListProps {
  messages: MessageType[]
  height: number
  itemHeight: number
}

export function VirtualizedMessageList({ messages, height, itemHeight }: VirtualizedMessageListProps) {
  const memoizedMessages = useMemo(() => messages, [messages])
  
  const Row = useCallback(({ index, style }) => (
    <div style={style}>
      <MessageComponent 
        message={memoizedMessages[index]} 
        isStatic={true}
      />
    </div>
  ), [memoizedMessages])
  
  return (
    <List
      height={height}
      itemCount={messages.length}
      itemSize={itemHeight}
      itemData={memoizedMessages}
    >
      {Row}
    </List>
  )
}
```

#### 2. Ê∂àÊÅØÁªÑ‰ª∂‰ºòÂåñ
```tsx
// components/OptimizedMessageComponent.tsx
import { memo, useMemo } from 'react'

interface MessageComponentProps {
  message: MessageType
  isStatic?: boolean
  onToolUse?: (toolId: string) => void
}

export const MessageComponent = memo<MessageComponentProps>(({ 
  message, 
  isStatic = false,
  onToolUse 
}) => {
  // üîß Âè™ÊúâÂú®ÈùûÈùôÊÄÅÊ®°ÂºèÊàñÊ∂àÊÅØÂÜÖÂÆπÂèòÂåñÊó∂ÊâçÈáçÊñ∞ËÆ°ÁÆó
  const processedContent = useMemo(() => {
    if (isStatic && message.type === 'assistant') {
      // ÈùôÊÄÅÊ∂àÊÅØ‰ΩøÁî®ÁºìÂ≠òÁöÑÂ§ÑÁêÜÁªìÊûú
      return message.cachedContent || processMessage(message.content)
    }
    return processMessage(message.content)
  }, [message, isStatic])
  
  // üîß Â∑•ÂÖ∑‰ΩøÁî®ÂõûË∞É‰ºòÂåñ
  const handleToolUse = useCallback((toolId: string) => {
    if (!isStatic && onToolUse) {
      onToolUse(toolId)
    }
  }, [isStatic, onToolUse])
  
  return (
    <Box flexDirection="column">
      {/* Ê∏≤ÊüìÈÄªËæë */}
      {processedContent}
    </Box>
  )
}, (prevProps, nextProps) => {
  // üîß Ëá™ÂÆö‰πâÊØîËæÉÂáΩÊï∞
  return (
    prevProps.message === nextProps.message &&
    prevProps.isStatic === nextProps.isStatic &&
    prevProps.onToolUse === nextProps.onToolUse
  )
})
```

#### 3. Áä∂ÊÄÅÊõ¥Êñ∞‰ºòÂåñ
```tsx
// hooks/useOptimizedREPL.ts
export function useOptimizedREPL() {
  // üîß ‰ΩøÁî® useCallback Á®≥ÂÆöÂáΩÊï∞ÂºïÁî®
  const stableCallbacks = useMemo(() => ({
    onMessageUpdate: useCallback((messageId: string, updates: Partial<MessageType>) => {
      setMessages(prev => prev.map(msg => 
        msg.id === messageId ? { ...msg, ...updates } : msg
      ))
    }, []),
    
    onMessageAdd: useCallback((newMessage: MessageType) => {
      setMessages(prev => [...prev, newMessage])
    }, []),
    
    onMessageRemove: useCallback((messageId: string) => {
      setMessages(prev => prev.filter(msg => msg.id !== messageId))
    }, [])
  }), [])
  
  // üîß ‰ΩøÁî® useDeferredValue Âª∂ËøüÈùûÂÖ≥ÈîÆÊõ¥Êñ∞
  const deferredMessages = useDeferredValue(messages)
  
  return {
    messages: deferredMessages,
    ...stableCallbacks
  }
}
```

## ÁõëÊéßÂíåË∞ÉËØïÁ≥ªÁªü

### 1. Áä∂ÊÄÅÂèòÂåñÁõëÊéß
```tsx
// utils/stateMonitor.ts
interface StateChange {
  timestamp: number
  component: string
  stateName: string
  oldValue: any
  newValue: any
  stackTrace?: string
}

class StateMonitor {
  private changes: StateChange[] = []
  private maxHistorySize = 1000
  
  recordChange(component: string, stateName: string, oldValue: any, newValue: any) {
    if (process.env.NODE_ENV !== 'development') return
    
    const change: StateChange = {
      timestamp: Date.now(),
      component,
      stateName,
      oldValue,
      newValue,
      stackTrace: new Error().stack
    }
    
    this.changes.push(change)
    
    // ‰øùÊåÅÂéÜÂè≤Â§ßÂ∞èÂú®ÈôêÂà∂ÂÜÖ
    if (this.changes.length > this.maxHistorySize) {
      this.changes.shift()
    }
    
    // Ê£ÄÊµãÊΩúÂú®ÈóÆÈ¢ò
    this.detectAnomalies(change)
  }
  
  private detectAnomalies(change: StateChange) {
    // Ê£ÄÊµãÂø´ÈÄüÁä∂ÊÄÅÂèòÂåñÔºàÂèØËÉΩÁöÑÊó†ÈôêÂæ™ÁéØÔºâ
    const recentChanges = this.changes.filter(c => 
      c.timestamp > Date.now() - 1000 && 
      c.component === change.component &&
      c.stateName === change.stateName
    )
    
    if (recentChanges.length > 10) {
      console.warn(`Rapid state changes detected in ${change.component}.${change.stateName}`, recentChanges)
    }
    
    // Ê£ÄÊµãÁä∂ÊÄÅ‰∏ç‰∏ÄËá¥
    if (change.stateName === 'isLoading' && change.newValue === true) {
      // Ê£ÄÊü•ÊòØÂê¶ÊúâÂØπÂ∫îÁöÑ currentRequest
      setTimeout(() => {
        const currentRequest = this.getLatestState(change.component, 'currentRequest')
        if (!currentRequest) {
          console.warn('isLoading=true but no currentRequest found')
        }
      }, 0)
    }
  }
  
  getLatestState(component: string, stateName: string) {
    const latest = this.changes
      .filter(c => c.component === component && c.stateName === stateName)
      .pop()
    return latest?.newValue
  }
  
  exportHistory() {
    return this.changes.slice()
  }
}

export const stateMonitor = new StateMonitor()

// Hook for monitoring state changes
export function useStateMonitor<T>(
  componentName: string, 
  stateName: string, 
  value: T
): T {
  const prevValue = useRef<T>()
  
  useEffect(() => {
    if (prevValue.current !== undefined && prevValue.current !== value) {
      stateMonitor.recordChange(componentName, stateName, prevValue.current, value)
    }
    prevValue.current = value
  }, [componentName, stateName, value])
  
  return value
}
```

### 2. ÊÄßËÉΩÁõëÊéß
```tsx
// utils/performanceMonitor.ts
interface PerformanceMetric {
  name: string
  duration: number
  timestamp: number
  metadata?: Record<string, any>
}

class PerformanceMonitor {
  private metrics: PerformanceMetric[] = []
  private activeTimers = new Map<string, number>()
  
  startTimer(name: string, metadata?: Record<string, any>) {
    this.activeTimers.set(name, performance.now())
    return () => this.endTimer(name, metadata)
  }
  
  endTimer(name: string, metadata?: Record<string, any>) {
    const startTime = this.activeTimers.get(name)
    if (!startTime) return
    
    const duration = performance.now() - startTime
    this.metrics.push({
      name,
      duration,
      timestamp: Date.now(),
      metadata
    })
    
    this.activeTimers.delete(name)
    
    // Ë≠¶ÂëäÊÖ¢Êìç‰Ωú
    if (duration > 100) {
      console.warn(`Slow operation detected: ${name} took ${duration.toFixed(2)}ms`, metadata)
    }
  }
  
  getMetrics(name?: string) {
    return name 
      ? this.metrics.filter(m => m.name === name)
      : this.metrics.slice()
  }
  
  getAverageTime(name: string, windowSize = 10) {
    const recent = this.metrics
      .filter(m => m.name === name)
      .slice(-windowSize)
    
    if (recent.length === 0) return 0
    
    return recent.reduce((sum, m) => sum + m.duration, 0) / recent.length
  }
}

export const performanceMonitor = new PerformanceMonitor()

// Hook for measuring component render time
export function useRenderPerformance(componentName: string) {
  useLayoutEffect(() => {
    const endTimer = performanceMonitor.startTimer(`${componentName}_render`)
    return endTimer
  })
}
```

### 3. ÈîôËØØËæπÁïåÂíåÊÅ¢Â§ç
```tsx
// components/REPLErrorBoundary.tsx
interface REPLErrorBoundaryState {
  hasError: boolean
  error?: Error
  errorInfo?: ErrorInfo
  errorId?: string
}

export class REPLErrorBoundary extends Component<
  PropsWithChildren<{}>,
  REPLErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props)
    this.state = { hasError: false }
  }
  
  static getDerivedStateFromError(error: Error): Partial<REPLErrorBoundaryState> {
    return {
      hasError: true,
      error,
      errorId: crypto.randomUUID()
    }
  }
  
  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    this.setState({ errorInfo })
    
    // ËÆ∞ÂΩïÈîôËØØËØ¶ÊÉÖ
    console.error('REPL Error Boundary caught error:', {
      error: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      errorId: this.state.errorId
    })
    
    // ÂèëÈÄÅÈîôËØØÊä•ÂëäÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
    if (process.env.NODE_ENV === 'production') {
      this.reportError(error, errorInfo)
    }
  }
  
  private reportError(error: Error, errorInfo: ErrorInfo) {
    // ÂÆûÁé∞ÈîôËØØÊä•ÂëäÈÄªËæë
    // ÂèØ‰ª•ÂèëÈÄÅÂà∞ÈîôËØØËøΩË∏™ÊúçÂä°
  }
  
  private handleRecovery = () => {
    this.setState({ 
      hasError: false, 
      error: undefined, 
      errorInfo: undefined,
      errorId: undefined 
    })
  }
  
  render() {
    if (this.state.hasError) {
      return (
        <Box flexDirection="column" padding={2}>
          <Text color="red" bold>Something went wrong in the REPL</Text>
          <Text>Error ID: {this.state.errorId}</Text>
          <Text wrap="wrap">{this.state.error?.message}</Text>
          
          <Box marginTop={1}>
            <Text bold>What you can do:</Text>
            <Text>‚Ä¢ Press Enter to try recovering</Text>
            <Text>‚Ä¢ Restart the application if problems persist</Text>
          </Box>
          
          <TextInput 
            placeholder="Press Enter to recover..."
            onSubmit={this.handleRecovery}
          />
        </Box>
      )
    }
    
    return this.props.children
  }
}
```

## Ë∞ÉËØïÂ∑•ÂÖ∑

### 1. ÂºÄÂèëËÄÖÊéßÂà∂Âè∞
```tsx
// components/DevConsole.tsx
export function DevConsole() {
  const [isVisible, setIsVisible] = useState(false)
  const [command, setCommand] = useState('')
  
  useInput((input, key) => {
    if (key.ctrl && input === 'd') {
      setIsVisible(!isVisible)
    }
  })
  
  if (!isVisible || process.env.NODE_ENV !== 'development') {
    return null
  }
  
  const handleCommand = (cmd: string) => {
    const [action, ...args] = cmd.split(' ')
    
    switch (action) {
      case 'state':
        console.log('Current REPL state:', stateMonitor.exportHistory().slice(-10))
        break
      
      case 'performance':
        const metric = args[0]
        console.log(`Performance for ${metric}:`, performanceMonitor.getMetrics(metric))
        break
      
      case 'clear':
        console.clear()
        break
      
      default:
        console.log('Available commands: state, performance <metric>, clear')
    }
    
    setCommand('')
  }
  
  return (
    <Box 
      position="absolute" 
      top={0} 
      left={0} 
      right={0} 
      bottom={0} 
      backgroundColor="black"
      borderStyle="double"
      flexDirection="column"
      zIndex={1000}
    >
      <Text bold color="cyan">Developer Console (Ctrl+D to toggle)</Text>
      <TextInput 
        placeholder="Enter command..."
        value={command}
        onChange={setCommand}
        onSubmit={handleCommand}
      />
    </Box>
  )
}
```

## ÂÆûÊñΩ‰ºòÂÖàÁ∫ß

### È´ò‰ºòÂÖàÁ∫ßÔºàÁ´ãÂç≥ÂÆûÊñΩÔºâ
1. ÈîôËØØËæπÁïåÂíåÂü∫Á°ÄÁõëÊéß
2. Áä∂ÊÄÅÂèòÂåñÁõëÊéß
3. ÂÖ≥ÈîÆÊÄßËÉΩÊåáÊ†áÊî∂ÈõÜ

### ‰∏≠‰ºòÂÖàÁ∫ßÔºà2-4Âë®ÂÜÖÔºâ
1. Ê∂àÊÅØÊ∏≤Êüì‰ºòÂåñ
2. ËôöÊãüÂåñÂÆûÁé∞
3. ÊÄßËÉΩÁõëÊéßÂÆåÂñÑ

### ‰Ωé‰ºòÂÖàÁ∫ßÔºà1-2‰∏™ÊúàÂÜÖÔºâ
1. ÂºÄÂèëËÄÖÊéßÂà∂Âè∞
2. È´òÁ∫ßË∞ÉËØïÂäüËÉΩ
3. Ëá™Âä®ÂåñÊÄßËÉΩÊµãËØï

## È¢ÑÊúüÊî∂Áõä

- ‚úÖ **50%+ Ê∏≤ÊüìÊÄßËÉΩÊèêÂçá**ÔºöÈÄöËøáËôöÊãüÂåñÂíå‰ºòÂåñ
- ‚úÖ **ÂÆûÊó∂ÈóÆÈ¢òÁõëÊéß**ÔºöÂèäÊó©ÂèëÁé∞Âíå‰øÆÂ§çÈóÆÈ¢ò
- ‚úÖ **Êõ¥Â•ΩÁöÑÈîôËØØÊÅ¢Â§ç**ÔºöÁî®Êà∑ÂèØ‰ª•‰ªéÈîôËØØ‰∏≠ÊÅ¢Â§çËÄå‰∏çÈáçÂêØ
- ‚úÖ **Êï∞ÊçÆÈ©±Âä®‰ºòÂåñ**ÔºöÂü∫‰∫éÁúüÂÆûÊÄßËÉΩÊï∞ÊçÆËøõË°åÊîπËøõ
- ‚úÖ **ÂºÄÂèë‰ΩìÈ™åÊèêÂçá**ÔºöÊõ¥Â•ΩÁöÑË∞ÉËØïÂ∑•ÂÖ∑ÂíåÈîôËØØ‰ø°ÊÅØ