<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Wars - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            cursor: crosshair;
        }
        .ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 18px;
            z-index: 100;
            text-shadow: 0 0 10px #00ff00;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff00;
        }
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #ff0000;
            border-radius: 50%;
            z-index: 100;
            pointer-events: none;
        }
        .crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #ff0000;
            border-radius: 50%;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #00ff00;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00ff00;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 36px;
            text-align: center;
            z-index: 100;
            display: none;
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 15px;
            border: 3px solid #ff4444;
            text-shadow: 0 0 20px #ff4444;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ff00;
            font-size: 24px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Loading Star Wars Battle...</div>
    <div class="crosshair" id="crosshair" style="display: none;"></div>
    <div class="ui" style="display: none;" id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div>Shield: <span id="shield">100</span></div>
        <div>Energy: <span id="energy">100</span></div>
        <div>Wave: <span id="wave">1</span></div>
        <div>Enemies: <span id="enemies">0</span></div>
        <div>Allies: <span id="allies">0</span></div>
        <div>Weapon: <span id="weapon">Laser</span></div>
        <div>Missiles: <span id="missiles">5</span></div>
    </div>
    <div class="controls" style="display: none;" id="controls">
        WASD - Move Ship<br>
        Mouse - Look Around<br>
        Click - Shoot Lasers<br>
        Space - Boost<br>
        M - Toggle Music<br>
        R - Restart
    </div>
    <div class="game-over" id="gameOver">
        <div>Game Over!</div>
        <div style="font-size: 20px; margin-top: 10px;">Final Score: <span id="finalScore">0</span></div>
        <div style="font-size: 18px; margin-top: 10px;">Press R to restart</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Enhanced Audio Context and Sound Effects
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function createTone(frequency, type, duration, volume = 0.3) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playLaserSound() {
            // Classic laser sound effect
            createTone(800, 'sawtooth', 0.1, 0.2);
            setTimeout(() => createTone(400, 'sawtooth', 0.05, 0.1), 20);
            setTimeout(() => createTone(200, 'sawtooth', 0.03, 0.05), 40);
        }

        function playExplosionSound() {
            // Enhanced explosion with multiple frequencies
            createTone(100, 'square', 0.3, 0.5);
            setTimeout(() => createTone(80, 'square', 0.2, 0.4), 100);
            setTimeout(() => createTone(60, 'square', 0.4, 0.3), 200);
            setTimeout(() => createTone(40, 'square', 0.3, 0.2), 400);
        }

        function playHitSound() {
            // Shield hit effect
            createTone(200, 'triangle', 0.1, 0.3);
            setTimeout(() => createTone(150, 'triangle', 0.08, 0.2), 50);
        }

        function playEngineSound() {
            // Spaceship engine rumble
            createTone(150, 'square', 0.1, 0.1);
            setTimeout(() => createTone(140, 'square', 0.08, 0.08), 30);
        }

        function playMissileSound() {
            // Missile launch sound
            createTone(400, 'square', 0.2, 0.3);
            setTimeout(() => createTone(350, 'square', 0.15, 0.25), 50);
            setTimeout(() => createTone(300, 'square', 0.1, 0.2), 100);
        }

        function playBossWarningSound() {
            // Boss approaching warning
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    createTone(1000, 'sine', 0.3, 0.4);
                    setTimeout(() => createTone(800, 'sine', 0.3, 0.4), 150);
                }, i * 600);
            }
        }

        function playUpgradeSound() {
            // Weapon upgrade chime
            const notes = [523.25, 659.25, 783.99, 1046.50]; // C-E-G-C
            notes.forEach((freq, i) => {
                setTimeout(() => createTone(freq, 'sine', 0.2, 0.3), i * 100);
            });
        }

        // Background Music System
        let backgroundMusicPlaying = false;
        let musicInterval;
        let musicNoteIndex = 0;

        // Star Wars-inspired melody (simplified)
        const backgroundMelody = [
            523.25, 523.25, 523.25, 698.46, 1046.50, 932.33, 880.00, 783.99, 1396.91, 1046.50, 932.33, 880.00, 783.99, 1396.91, 1046.50
        ];

        function startBackgroundMusic() {
            if (backgroundMusicPlaying) return;
            backgroundMusicPlaying = true;
            
            musicInterval = setInterval(() => {
                if (gameRunning && !isPaused) {
                    const frequency = backgroundMelody[musicNoteIndex];
                    createTone(frequency, 'sine', 0.4, 0.05);
                    musicNoteIndex = (musicNoteIndex + 1) % backgroundMelody.length;
                }
            }, 500);
        }

        function stopBackgroundMusic() {
            backgroundMusicPlaying = false;
            if (musicInterval) {
                clearInterval(musicInterval);
            }
        }

        // Ambient space sounds
        function playAmbientSound() {
            if (Math.random() < 0.001) {
                // Occasional distant explosions or ship fly-bys
                const type = Math.random() < 0.5 ? 'explosion' : 'flyby';
                if (type === 'explosion') {
                    setTimeout(() => createTone(50 + Math.random() * 50, 'square', 0.5, 0.02), Math.random() * 1000);
                } else {
                    // Ship flyby effect
                    for (let i = 0; i < 10; i++) {
                        setTimeout(() => {
                            const freq = 300 + i * 20;
                            createTone(freq, 'sawtooth', 0.05, 0.02);
                        }, i * 50);
                    }
                }
            }
        }

        // Game Variables
        let score = 0;
        let health = 100;
        let maxHealth = 100;
        let shield = 100;
        let maxShield = 100;
        let energy = 100;
        let maxEnergy = 100;
        let wave = 1;
        let gameRunning = true;
        let enemies = [];
        let allies = [];
        let lasers = [];
        let explosions = [];
        let stars = [];
        let enemyLasers = [];
        let missiles = [];
        let powerUps = [];
        let capitalShips = [];

        // Player stats and upgrades
        let playerStats = {
            weaponType: 'laser', // laser, rapid, spread, missile
            fireRate: 100,
            damage: 1,
            speed: 0.15,
            shield: 100,
            missiles: 5,
            energy: 100
        };

        // AI Ally System
        class Ally {
            constructor(x, y, z, type = 'wingman') {
                this.type = type;
                this.mesh = new THREE.Mesh(shipGeometry, 
                    new THREE.MeshPhongMaterial({ 
                        color: 0x4444ff, 
                        emissive: 0x001144 
                    })
                );
                this.mesh.position.set(x, y, z);
                this.mesh.scale.setScalar(0.8);
                this.mesh.castShadow = true;
                
                this.target = null;
                this.formationOffset = new THREE.Vector3(x, y, z);
                this.lastShot = 0;
                this.fireRate = 1500;
                this.health = 50;
                this.maxHealth = 50;
                
                scene.add(this.mesh);
            }

            update() {
                // Formation flying with player
                const formationPos = playerShip.position.clone().add(this.formationOffset);
                const direction = new THREE.Vector3();
                direction.subVectors(formationPos, this.mesh.position);
                direction.normalize();
                direction.multiplyScalar(0.02);
                this.mesh.position.add(direction);

                // Look for nearest enemy
                let nearestEnemy = null;
                let minDistance = Infinity;
                enemies.forEach(enemy => {
                    const distance = enemy.mesh.position.distanceTo(this.mesh.position);
                    if (distance < minDistance && distance < 40) {
                        minDistance = distance;
                        nearestEnemy = enemy;
                    }
                });

                this.target = nearestEnemy;

                // Shoot at target
                if (this.target && Date.now() - this.lastShot > this.fireRate) {
                    this.shoot();
                    this.lastShot = Date.now();
                }

                // Rotate towards movement direction
                if (direction.length() > 0) {
                    this.mesh.lookAt(this.mesh.position.clone().add(direction));
                }
            }

            shoot() {
                const laser = new THREE.Mesh(laserGeometry, 
                    new THREE.MeshBasicMaterial({ color: 0x4444ff })
                );
                laser.position.copy(this.mesh.position);
                
                const direction = new THREE.Vector3();
                direction.subVectors(this.target.mesh.position, laser.position);
                direction.normalize();
                
                laser.userData = { 
                    direction: direction, 
                    speed: 0.4, 
                    damage: 1,
                    type: 'ally',
                    ally: true
                };
                
                lasers.push(laser);
                scene.add(laser);
                
                // Ally laser sound (quieter)
                createTone(600, 'sawtooth', 0.05, 0.1);
            }

            takeDamage(damage) {
                this.health -= damage;
                
                // Visual damage effect
                this.mesh.material.emissive.multiplyScalar(3);
                setTimeout(() => {
                    if (this.mesh.material) {
                        this.mesh.material.emissive.multiplyScalar(0.33);
                    }
                }, 100);
                
                if (this.health <= 0) {
                    this.destroy();
                    return true;
                }
                return false;
            }

            destroy() {
                createExplosion(this.mesh.position, 8);
                scene.remove(this.mesh);
                const index = allies.indexOf(this);
                if (index > -1) {
                    allies.splice(index, 1);
                }
            }
        }

        // Camera shake
        let cameraShake = { intensity: 0, duration: 0, startTime: 0 };

        function shakeCamera(duration, intensity = 0.5) {
            cameraShake.intensity = intensity;
            cameraShake.duration = duration;
            cameraShake.startTime = Date.now();
        }

        // Controls
        const keys = {
            w: false, a: false, s: false, d: false, space: false
        };
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        // Three.js Setup
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 200);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000011, 1);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(50, 50, 50);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Materials
        const playerMaterial = new THREE.MeshPhongMaterial({ color: 0x888888, emissive: 0x222222 });
        const enemyMaterial = new THREE.MeshPhongMaterial({ color: 0xff4444, emissive: 0x441111 });
        const laserMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const enemyLaserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const missileMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const starMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

        // Geometries
        const shipGeometry = new THREE.ConeGeometry(0.5, 2, 8);
        const enemyGeometry = new THREE.OctahedronGeometry(0.8);
        const laserGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1);
        const missileGeometry = new THREE.CylinderGeometry(0.1, 0.15, 0.8);
        const starGeometry = new THREE.SphereGeometry(0.1, 4, 4);

        // Player Ship
        const playerShip = new THREE.Mesh(shipGeometry, playerMaterial);
        playerShip.position.set(0, 0, 0);
        playerShip.castShadow = true;
        scene.add(playerShip);

        // Camera setup
        camera.position.set(0, 2, 5);
        camera.lookAt(playerShip.position);

        // Create Star Field with nebula and planets
        function createStars() {
            // Background stars
            for (let i = 0; i < 200; i++) {
                const star = new THREE.Mesh(starGeometry, starMaterial);
                star.position.set(
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200,
                    (Math.random() - 0.5) * 200
                );
                star.scale.setScalar(Math.random() * 0.5 + 0.5);
                stars.push(star);
                scene.add(star);
            }
            
            // Add distant planet
            const planetGeometry = new THREE.SphereGeometry(10, 32, 32);
            const planetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x4444ff,
                emissive: 0x111144
            });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.position.set(-80, 20, -100);
            scene.add(planet);
            
            // Add space station
            const stationGeometry = new THREE.CylinderGeometry(3, 3, 8, 8);
            const stationMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x888888,
                emissive: 0x222222
            });
            const station = new THREE.Mesh(stationGeometry, stationMaterial);
            station.position.set(60, -30, -80);
            station.rotation.x = Math.PI / 4;
            scene.add(station);
            
            // Add some asteroids
            for (let i = 0; i < 10; i++) {
                const asteroidGeometry = new THREE.DodecahedronGeometry(Math.random() * 2 + 1);
                const asteroidMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x666655,
                    emissive: 0x222211
                });
                const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
                asteroid.position.set(
                    (Math.random() - 0.5) * 120,
                    (Math.random() - 0.5) * 60,
                    (Math.random() - 0.5) * 120
                );
                asteroid.rotation.set(
                    Math.random() * Math.PI,
                    Math.random() * Math.PI,
                    Math.random() * Math.PI
                );
                scene.add(asteroid);
            }
            
            // Add nebula-like effect with colored fog
            const nebulaGeometry = new THREE.SphereGeometry(50, 16, 16);
            const nebulaMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x440088,
                transparent: true,
                opacity: 0.1
            });
            const nebula = new THREE.Mesh(nebulaGeometry, nebulaMaterial);
            nebula.position.set(40, 10, -50);
            scene.add(nebula);
        }

        // Enemy Class
        class Enemy {
            constructor(x, y, z, type = 'fighter') {
                this.type = type;
                this.setupMesh();
                this.mesh.position.set(x, y, z);
                this.mesh.castShadow = true;
                
                // AI behavior patterns
                this.aiState = 'patrol'; // patrol, attack, retreat, formation
                this.target = playerShip.position.clone();
                this.formationPosition = new THREE.Vector3(x, y, z);
                this.patrolRadius = 10;
                this.attackCooldown = 0;
                this.retreatTimer = 0;
                
                this.setupStats();
                scene.add(this.mesh);
            }

            setupMesh() {
                switch(this.type) {
                    case 'fighter':
                        this.mesh = new THREE.Mesh(enemyGeometry, enemyMaterial);
                        break;
                    case 'interceptor':
                        this.mesh = new THREE.Mesh(
                            new THREE.ConeGeometry(0.4, 1.5, 6),
                            new THREE.MeshPhongMaterial({ color: 0xff6600, emissive: 0x442200 })
                        );
                        break;
                    case 'bomber':
                        this.mesh = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 0.5, 2),
                            new THREE.MeshPhongMaterial({ color: 0x660066, emissive: 0x220022 })
                        );
                        break;
                    case 'boss':
                        this.mesh = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(2),
                            new THREE.MeshPhongMaterial({ color: 0xff0000, emissive: 0x440000 })
                        );
                        break;
                }
            }

            setupStats() {
                switch(this.type) {
                    case 'fighter':
                        this.health = 1;
                        this.speed = 0.008;
                        this.fireRate = 2000;
                        this.damage = 10;
                        this.points = 10;
                        break;
                    case 'interceptor':
                        this.health = 2;
                        this.speed = 0.015;
                        this.fireRate = 1500;
                        this.damage = 15;
                        this.points = 25;
                        break;
                    case 'bomber':
                        this.health = 3;
                        this.speed = 0.005;
                        this.fireRate = 3000;
                        this.damage = 25;
                        this.points = 50;
                        break;
                    case 'boss':
                        this.health = 20;
                        this.speed = 0.003;
                        this.fireRate = 500;
                        this.damage = 30;
                        this.points = 500;
                        break;
                }
                this.maxHealth = this.health;
                this.lastShot = 0;
            }

            update() {
                this.updateAI();
                this.updateRotation();
                this.updateShooting();
                
                // Remove if too far
                if (this.mesh.position.distanceTo(playerShip.position) > 150) {
                    this.destroy();
                    return false;
                }
                return true;
            }

            updateAI() {
                const distanceToPlayer = this.mesh.position.distanceTo(playerShip.position);
                const direction = new THREE.Vector3();
                
                switch(this.aiState) {
                    case 'patrol':
                        // Circle around formation position
                        const angle = Date.now() * 0.001;
                        this.target.set(
                            this.formationPosition.x + Math.cos(angle) * this.patrolRadius,
                            this.formationPosition.y + Math.sin(angle * 0.5) * 5,
                            this.formationPosition.z + Math.sin(angle) * this.patrolRadius
                        );
                        
                        if (distanceToPlayer < 25) {
                            this.aiState = 'attack';
                        }
                        break;
                        
                    case 'attack':
                        // Aggressive pursuit
                        this.target.copy(playerShip.position);
                        
                        // Add some evasive maneuvers
                        const evasion = new THREE.Vector3(
                            Math.sin(Date.now() * 0.01) * 2,
                            Math.cos(Date.now() * 0.008) * 2,
                            0
                        );
                        this.target.add(evasion);
                        
                        if (this.health < this.maxHealth * 0.3) {
                            this.aiState = 'retreat';
                            this.retreatTimer = Date.now();
                        }
                        break;
                        
                    case 'retreat':
                        // Move away from player
                        direction.subVectors(this.mesh.position, playerShip.position);
                        direction.normalize();
                        this.target.copy(this.mesh.position).add(direction.multiplyScalar(10));
                        
                        if (Date.now() - this.retreatTimer > 3000) {
                            this.aiState = 'attack';
                        }
                        break;
                }
                
                // Move towards target
                direction.subVectors(this.target, this.mesh.position);
                direction.normalize();
                direction.multiplyScalar(this.speed);
                this.mesh.position.add(direction);
            }

            updateRotation() {
                // Rotate based on movement direction and type
                if (this.type === 'boss') {
                    this.mesh.rotation.x += 0.01;
                    this.mesh.rotation.y += 0.005;
                    this.mesh.rotation.z += 0.008;
                } else {
                    this.mesh.rotation.x += 0.02;
                    this.mesh.rotation.y += 0.01;
                    
                    // Face movement direction
                    const direction = new THREE.Vector3();
                    direction.subVectors(this.target, this.mesh.position);
                    this.mesh.lookAt(this.target);
                }
            }

            updateShooting() {
                if (Date.now() - this.lastShot > this.fireRate + Math.random() * 1000) {
                    const distanceToPlayer = this.mesh.position.distanceTo(playerShip.position);
                    
                    // Only shoot if player is in range and roughly in front
                    if (distanceToPlayer < 40 && this.aiState === 'attack') {
                        this.shoot();
                        this.lastShot = Date.now();
                    }
                }
            }

            shoot() {
                const numLasers = this.type === 'boss' ? 3 : 1;
                
                for (let i = 0; i < numLasers; i++) {
                    const laser = new THREE.Mesh(laserGeometry, enemyLaserMaterial);
                    laser.position.copy(this.mesh.position);
                    
                    if (numLasers > 1) {
                        // Spread shots for boss
                        laser.position.x += (i - 1) * 0.5;
                    }
                    
                    const direction = new THREE.Vector3();
                    direction.subVectors(playerShip.position, laser.position);
                    direction.normalize();
                    
                    // Add some inaccuracy except for boss
                    if (this.type !== 'boss') {
                        direction.x += (Math.random() - 0.5) * 0.2;
                        direction.y += (Math.random() - 0.5) * 0.2;
                        direction.normalize();
                    }
                    
                    laser.userData = { 
                        direction: direction, 
                        speed: 0.3, 
                        enemy: true,
                        damage: this.damage
                    };
                    
                    enemyLasers.push(laser);
                    scene.add(laser);
                }
            }

            takeDamage(damage = 1) {
                this.health -= damage;
                
                // Visual damage effect
                this.mesh.material.emissive.multiplyScalar(2);
                setTimeout(() => {
                    if (this.mesh.material) {
                        this.mesh.material.emissive.multiplyScalar(0.5);
                    }
                }, 100);
                
                if (this.health <= 0) {
                    this.explode();
                    this.destroy();
                    score += this.points;
                    return true;
                }
                return false;
            }

            explode() {
                const explosionSize = this.type === 'boss' ? 20 : 10;
                createExplosion(this.mesh.position, explosionSize);
                playExplosionSound();
                
                // Screen shake for boss
                if (this.type === 'boss') {
                    shakeCamera(1000);
                }
            }

            destroy() {
                scene.remove(this.mesh);
                const index = enemies.indexOf(this);
                if (index > -1) {
                    enemies.splice(index, 1);
                }
            }
        }

        // Enhanced laser shooting with energy consumption
        function shootLaser() {
            // Energy cost for weapons
            const energyCost = {
                laser: 2,
                rapid: 1,
                spread: 4,
                missile: 15
            };
            
            if (energy < energyCost[playerStats.weaponType]) {
                // Not enough energy
                createTone(200, 'square', 0.1, 0.1);
                return;
            }
            
            energy -= energyCost[playerStats.weaponType];
            
            switch(playerStats.weaponType) {
                case 'laser':
                    shootSingleLaser();
                    break;
                case 'rapid':
                    shootSingleLaser();
                    break;
                case 'spread':
                    shootSpreadLaser();
                    break;
                case 'missile':
                    shootMissile();
                    break;
            }
        }

        // Shield and energy regeneration
        function updateShieldAndEnergy() {
            // Energy regeneration
            if (energy < maxEnergy) {
                energy += 0.3;
                energy = Math.min(energy, maxEnergy);
            }
            
            // Shield regeneration (when not taking damage)
            if (shield < maxShield && !playerTakingDamage) {
                shield += 0.2;
                shield = Math.min(shield, maxShield);
            }
        }

        // Enhanced damage system
        let playerTakingDamage = false;
        let damageRecoveryTimer = 0;

        function playerTakeDamage(damage) {
            playerTakingDamage = true;
            damageRecoveryTimer = Date.now();
            
            if (shield > 0) {
                // Shield absorbs damage
                shield -= damage;
                playHitSound();
                
                // Shield visual effect
                const shieldEffect = new THREE.Mesh(
                    new THREE.SphereGeometry(2),
                    new THREE.MeshBasicMaterial({ 
                        color: 0x4444ff, 
                        transparent: true, 
                        opacity: 0.3 
                    })
                );
                shieldEffect.position.copy(playerShip.position);
                scene.add(shieldEffect);
                
                setTimeout(() => {
                    scene.remove(shieldEffect);
                }, 200);
                
                if (shield < 0) {
                    const overflow = -shield;
                    shield = 0;
                    health -= overflow;
                }
            } else {
                // Direct hull damage
                health -= damage;
                createTone(150, 'square', 0.2, 0.3);
                shakeCamera(300, 0.4);
            }
            
            // Check for game over
            if (health <= 0) {
                gameOver();
            }
        }

        function shootSingleLaser() {
            const laser = new THREE.Mesh(laserGeometry, laserMaterial);
            laser.position.copy(playerShip.position);
            laser.position.y += 0.5;
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            laser.userData = { 
                direction: direction, 
                speed: 0.5, 
                damage: playerStats.damage,
                type: 'laser'
            };
            
            lasers.push(laser);
            scene.add(laser);
            playLaserSound();
        }

        function shootSpreadLaser() {
            for (let i = -1; i <= 1; i++) {
                const laser = new THREE.Mesh(laserGeometry, laserMaterial);
                laser.position.copy(playerShip.position);
                laser.position.y += 0.5;
                laser.position.x += i * 0.3;
                
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.x += i * 0.2;
                direction.normalize();
                
                laser.userData = { 
                    direction: direction, 
                    speed: 0.5, 
                    damage: playerStats.damage * 0.8,
                    type: 'laser'
                };
                
                lasers.push(laser);
                scene.add(laser);
            }
            playLaserSound();
        }

        function shootMissile() {
            if (playerStats.missiles <= 0) return;
            
            playerStats.missiles--;
            
            const missile = new THREE.Mesh(missileGeometry, missileMaterial);
            missile.position.copy(playerShip.position);
            missile.position.y += 0.5;
            
            // Find nearest enemy for homing
            let target = null;
            let minDistance = Infinity;
            enemies.forEach(enemy => {
                const distance = enemy.mesh.position.distanceTo(playerShip.position);
                if (distance < minDistance && distance < 50) {
                    minDistance = distance;
                    target = enemy;
                }
            });
            
            const direction = new THREE.Vector3();
            if (target) {
                direction.subVectors(target.mesh.position, missile.position);
            } else {
                camera.getWorldDirection(direction);
            }
            direction.normalize();
            
            missile.userData = { 
                direction: direction, 
                speed: 0.3, 
                damage: playerStats.damage * 3,
                type: 'missile',
                target: target,
                homing: true
            };
            
            lasers.push(missile);
            scene.add(missile);
            playMissileSound(); // Use new missile sound
        }

        // Enhanced Explosion effect
        function createExplosion(position, size = 10) {
            const particles = [];
            for (let i = 0; i < size; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1 + Math.random() * 0.1),
                    new THREE.MeshBasicMaterial({ 
                        color: new THREE.Color().setHSL(Math.random() * 0.1, 1, 0.5 + Math.random() * 0.5)
                    })
                );
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3,
                        (Math.random() - 0.5) * 0.3
                    ),
                    life: 1.0,
                    maxLife: 1.0
                };
                particles.push(particle);
                scene.add(particle);
            }
            explosions.push(particles);
        }

        // Spawn enemies with different types based on wave
        function spawnEnemies() {
            const numEnemies = wave + 2;
            let hasBoss = false;
            
            for (let i = 0; i < numEnemies; i++) {
                const angle = (i / numEnemies) * Math.PI * 2;
                const radius = 30 + Math.random() * 20;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const y = (Math.random() - 0.5) * 10;
                
                // Choose enemy type based on wave
                let type = 'fighter';
                if (wave >= 3 && Math.random() < 0.3) type = 'interceptor';
                if (wave >= 5 && Math.random() < 0.2) type = 'bomber';
                if (wave % 5 === 0 && i === 0 && !hasBoss) {
                    type = 'boss';
                    hasBoss = true;
                    playBossWarningSound(); // Boss warning sound
                }
                
                enemies.push(new Enemy(x, y, z, type));
            }
        }

        // Update game
        function updateGame() {
            if (!gameRunning) return;

            // Apply camera shake
            if (cameraShake.duration > 0) {
                const elapsed = Date.now() - cameraShake.startTime;
                if (elapsed < cameraShake.duration) {
                    const intensity = cameraShake.intensity * (1 - elapsed / cameraShake.duration);
                    camera.position.x += (Math.random() - 0.5) * intensity;
                    camera.position.y += (Math.random() - 0.5) * intensity;
                }
            }

            // Update shield and energy
            updateShieldAndEnergy();
            
            // Check damage recovery
            if (playerTakingDamage && Date.now() - damageRecoveryTimer > 3000) {
                playerTakingDamage = false;
            }

            // Update player movement
            const moveSpeed = keys.space ? playerStats.speed * 2 : playerStats.speed;
            if (keys.w) playerShip.position.z -= moveSpeed;
            if (keys.s) playerShip.position.z += moveSpeed;
            if (keys.a) playerShip.position.x -= moveSpeed;
            if (keys.d) playerShip.position.x += moveSpeed;

            // Update camera to follow mouse
            const targetX = mouseX * 0.001;
            const targetY = mouseY * 0.001;
            camera.position.x += (targetX - camera.position.x) * 0.05;
            camera.position.y += (targetY - camera.position.y) * 0.05;
            camera.lookAt(playerShip.position);

            // Engine sound
            if (keys.w || keys.s || keys.a || keys.d) {
                if (Math.random() < 0.1) playEngineSound();
            }

            // Play ambient sounds
            playAmbientSound();

            // Update allies
            allies.forEach(ally => ally.update());

            // Update enemies
            enemies.forEach(enemy => enemy.update());

            // Update lasers and missiles
            for (let i = lasers.length - 1; i >= 0; i--) {
                const projectile = lasers[i];
                
                // Homing missile logic
                if (projectile.userData.homing && projectile.userData.target) {
                    const target = projectile.userData.target;
                    if (target.mesh.parent) { // Target still exists
                        const direction = new THREE.Vector3();
                        direction.subVectors(target.mesh.position, projectile.position);
                        direction.normalize();
                        
                        // Gradually adjust direction
                        projectile.userData.direction.lerp(direction, 0.1);
                        projectile.userData.direction.normalize();
                    }
                }
                
                projectile.position.add(projectile.userData.direction.clone().multiplyScalar(projectile.userData.speed));
                
                // Missile trail effect
                if (projectile.userData.type === 'missile') {
                    if (Math.random() < 0.3) {
                        const trail = new THREE.Mesh(
                            new THREE.SphereGeometry(0.05),
                            new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.8 })
                        );
                        trail.position.copy(projectile.position);
                        trail.userData = { life: 0.5, maxLife: 0.5 };
                        scene.add(trail);
                        explosions.push([trail]);
                    }
                }
                
                // Check collision with enemies (for player and ally projectiles)
                if (!projectile.userData.enemy) {
                    let hit = false;
                    enemies.forEach(enemy => {
                        if (projectile.position.distanceTo(enemy.mesh.position) < 1) {
                            enemy.takeDamage(projectile.userData.damage);
                            hit = true;
                            playHitSound();
                            
                            // Larger explosion for missiles
                            if (projectile.userData.type === 'missile') {
                                createExplosion(projectile.position, 15);
                                shakeCamera(300, 0.3);
                            }
                        }
                    });

                    // Remove projectile if hit or out of bounds
                    if (hit || projectile.position.length() > 100) {
                        scene.remove(projectile);
                        lasers.splice(i, 1);
                    }
                }
            }

            // Update enemy lasers
            for (let i = enemyLasers.length - 1; i >= 0; i--) {
                const laser = enemyLasers[i];
                laser.position.add(laser.userData.direction.clone().multiplyScalar(laser.userData.speed));
                
                // Check collision with player
                if (laser.position.distanceTo(playerShip.position) < 1) {
                    const damage = laser.userData.damage || 10;
                    playerTakeDamage(damage);
                    scene.remove(laser);
                    enemyLasers.splice(i, 1);
                } 
                // Check collision with allies
                else {
                    let hitAlly = false;
                    allies.forEach(ally => {
                        if (laser.position.distanceTo(ally.mesh.position) < 1) {
                            ally.takeDamage(laser.userData.damage || 10);
                            hitAlly = true;
                        }
                    });
                    
                    if (hitAlly || laser.position.length() > 100) {
                        scene.remove(laser);
                        enemyLasers.splice(i, 1);
                    }
                }
            }

            // Update explosions with enhanced effects
            for (let i = explosions.length - 1; i >= 0; i--) {
                const particles = explosions[i];
                let allDead = true;
                
                particles.forEach(particle => {
                    particle.position.add(particle.userData.velocity);
                    particle.userData.velocity.multiplyScalar(0.98); // Slow down over time
                    particle.userData.life -= 0.02;
                    
                    const lifeRatio = particle.userData.life / particle.userData.maxLife;
                    particle.material.opacity = lifeRatio;
                    particle.scale.setScalar(lifeRatio);
                    
                    // Color transition for fire effect
                    if (particle.material.color) {
                        particle.material.color.setHSL(
                            0.1 * lifeRatio, 
                            1, 
                            0.5 + lifeRatio * 0.5
                        );
                    }
                    
                    if (particle.userData.life > 0) {
                        allDead = false;
                    }
                });
                
                if (allDead) {
                    particles.forEach(particle => scene.remove(particle));
                    explosions.splice(i, 1);
                }
            }

            // Update stars (moving effect)
            stars.forEach(star => {
                star.position.z += 0.1;
                if (star.position.z > 100) {
                    star.position.z = -100;
                }
                // Twinkling effect
                star.material.opacity = 0.5 + Math.sin(Date.now() * 0.01 + star.position.x) * 0.5;
            });

            // Check wave completion
            if (enemies.length === 0) {
                wave++;
                // Weapon upgrade every few waves
                if (wave % 3 === 0) {
                    upgradeWeapon();
                }
                // Add allies every few waves
                if (wave % 4 === 0 && allies.length < 3) {
                    spawnAlly();
                }
                setTimeout(() => spawnEnemies(), 2000);
            }

            // Update UI
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = Math.ceil(health);
            document.getElementById('shield').textContent = Math.ceil(shield);
            document.getElementById('energy').textContent = Math.ceil(energy);
            document.getElementById('wave').textContent = wave;
            document.getElementById('enemies').textContent = enemies.length;
            document.getElementById('allies').textContent = allies.length;
            document.getElementById('weapon').textContent = playerStats.weaponType.charAt(0).toUpperCase() + playerStats.weaponType.slice(1);
            document.getElementById('missiles').textContent = playerStats.missiles;
        }

        function spawnAlly() {
            const offsetX = allies.length * 4 - 6;
            const ally = new Ally(-offsetX, 2, 3);
            allies.push(ally);
            
            // Ally spawn sound
            createTone(800, 'sine', 0.3, 0.2);
        }

        function upgradeWeapon() {
            const upgrades = ['rapid', 'spread', 'missile'];
            const currentIndex = upgrades.indexOf(playerStats.weaponType);
            if (currentIndex < upgrades.length - 1) {
                playerStats.weaponType = upgrades[currentIndex + 1];
                playerStats.damage += 0.5;
                playerStats.missiles += 3;
            } else {
                playerStats.damage += 1;
                playerStats.missiles += 5;
            }
            
            // Visual and audio feedback
            createExplosion(playerShip.position, 8);
            playUpgradeSound(); // Use new upgrade sound
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
            
            // Stop background music and play enhanced game over sound
            stopBackgroundMusic();
            setTimeout(() => {
                createTone(220, 'sine', 1.0, 0.4);
                setTimeout(() => createTone(196, 'sine', 1.0, 0.4), 500);
                setTimeout(() => createTone(174, 'sine', 1.5, 0.4), 1000);
            }, 200);
        }

        function resetGame() {
            score = 0;
            health = 100;
            shield = 100;
            energy = 100;
            wave = 1;
            gameRunning = true;
            playerTakingDamage = false;
            
            // Reset player stats
            playerStats = {
                weaponType: 'laser',
                fireRate: 100,
                damage: 1,
                speed: 0.15,
                shield: 100,
                missiles: 5,
                energy: 100
            };
            
            // Clear all objects
            enemies.forEach(enemy => enemy.destroy());
            enemies = [];
            
            allies.forEach(ally => ally.destroy());
            allies = [];
            
            lasers.forEach(laser => scene.remove(laser));
            lasers = [];
            
            enemyLasers.forEach(laser => scene.remove(laser));
            enemyLasers = [];
            
            explosions.forEach(particles => {
                particles.forEach(particle => scene.remove(particle));
            });
            explosions = [];
            
            playerShip.position.set(0, 0, 0);
            document.getElementById('gameOver').style.display = 'none';
            
            spawnEnemies();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            updateGame();
            renderer.render(scene, camera);
        }

        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
            
            if (key === 'r') {
                resetGame();
            }
            
            if (key === 'm') {
                // Toggle background music
                if (backgroundMusicPlaying) {
                    stopBackgroundMusic();
                } else {
                    startBackgroundMusic();
                }
            }
            
            if (key === ' ') {
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });

        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2);
            mouseY = (e.clientY - window.innerHeight / 2);
        });

        document.addEventListener('mousedown', (e) => {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            isMouseDown = true;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Enhanced continuous shooting with fire rate
        let lastShot = 0;
        setInterval(() => {
            if (isMouseDown && gameRunning) {
                const now = Date.now();
                const fireRate = playerStats.weaponType === 'rapid' ? playerStats.fireRate / 2 : playerStats.fireRate;
                if (now - lastShot > fireRate) {
                    shootLaser();
                    lastShot = now;
                }
            }
        }, 50);

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Pointer lock for better mouse control
        document.addEventListener('click', () => {
            document.body.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === document.body) {
                document.addEventListener('mousemove', updateMousePosition);
            } else {
                document.removeEventListener('mousemove', updateMousePosition);
            }
        });

        function updateMousePosition(e) {
            mouseX += e.movementX * 0.5;
            mouseY += e.movementY * 0.5;
            
            // Limit mouse movement
            mouseX = Math.max(-window.innerWidth / 2, Math.min(window.innerWidth / 2, mouseX));
            mouseY = Math.max(-window.innerHeight / 2, Math.min(window.innerHeight / 2, mouseY));
        }

        // Initialize game
        setTimeout(() => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('crosshair').style.display = 'block';
            
            createStars();
            spawnEnemies();
            startBackgroundMusic(); // Start background music
            animate();
        }, 2000);
    </script>
</body>
</html>