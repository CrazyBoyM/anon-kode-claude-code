<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multi-Snake Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #gameCanvas {
            display: block;
        }
        
        #gameUI {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            z-index: 100;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            z-index: 100;
            text-align: right;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 200;
            display: none;
        }
        
        .player-score {
            margin-bottom: 10px;
        }
        
        .player1 { color: #ff4444; }
        .player2 { color: #4444ff; }
        .player3 { color: #44ff44; }
        .player4 { color: #ffff44; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="gameUI">
            <div class="player-score player1">Player 1: <span id="score1">0</span></div>
            <div class="player-score player2">Player 2: <span id="score2">0</span></div>
            <div class="player-score player3">Player 3: <span id="score3">0</span></div>
            <div class="player-score player4">Player 4: <span id="score4">0</span></div>
        </div>
        
        <div id="instructions">
            <div>Player 1: WASD + QE (Up/Down)</div>
            <div>Player 2: Arrow Keys + PgUp/PgDn</div>
            <div>Player 3: IJKL + UO</div>
            <div>Player 4: Numpad 4682 + 79</div>
            <div>Press R to restart</div>
        </div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p id="gameOverText"></p>
            <p>Press R to restart</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const CONFIG = {
            GRID_SIZE: 20,
            BOARD_SIZE: 40,
            SNAKE_SPEED: 0.1,
            FOOD_COUNT: 8,
            PLAYERS: 4
        };

        // Game State
        let scene, camera, renderer, gameBoard;
        let snakes = [];
        let foods = [];
        let gameRunning = true;
        let scores = [0, 0, 0, 0];
        
        // Input handling
        let keys = {};
        
        // Colors for different players
        const SNAKE_COLORS = [
            0xff4444, // Red
            0x4444ff, // Blue  
            0x44ff44, // Green
            0xffff44  // Yellow
        ];

        // Initialize the game
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 30);
            camera.lookAt(0, 0, 0);
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Setup lighting
            setupLighting();
            
            // Create game board
            createGameBoard();
            
            // Create snakes
            createSnakes();
            
            // Create initial food
            createFood();
            
            // Setup event listeners
            setupControls();
            
            // Start game loop
            gameLoop();
        }

        function setupLighting() {
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);
            
            // Directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(20, 20, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Point lights for ambiance
            const pointLight1 = new THREE.PointLight(0xff4444, 0.5, 50);
            pointLight1.position.set(-15, 10, -15);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0x4444ff, 0.5, 50);
            pointLight2.position.set(15, 10, 15);
            scene.add(pointLight2);
        }

        function createGameBoard() {
            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(CONFIG.BOARD_SIZE, CONFIG.BOARD_SIZE);
            const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x333333 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create walls
            const wallHeight = 5;
            const wallGeometry = new THREE.BoxGeometry(CONFIG.BOARD_SIZE, wallHeight, 1);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
            
            // Four walls
            const walls = [
                { pos: [0, wallHeight/2, CONFIG.BOARD_SIZE/2], rot: [0, 0, 0] },
                { pos: [0, wallHeight/2, -CONFIG.BOARD_SIZE/2], rot: [0, 0, 0] },
                { pos: [CONFIG.BOARD_SIZE/2, wallHeight/2, 0], rot: [0, Math.PI/2, 0] },
                { pos: [-CONFIG.BOARD_SIZE/2, wallHeight/2, 0], rot: [0, Math.PI/2, 0] }
            ];
            
            walls.forEach(wall => {
                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);
                wallMesh.position.set(...wall.pos);
                wallMesh.rotation.set(...wall.rot);
                wallMesh.castShadow = true;
                scene.add(wallMesh);
            });
        }

        // Snake class
        class Snake {
            constructor(startX, startZ, color, playerId) {
                this.segments = [];
                this.direction = { x: 1, y: 0, z: 0 };
                this.color = color;
                this.playerId = playerId;
                this.growing = false;
                
                // Create initial segments
                for (let i = 0; i < 3; i++) {
                    this.addSegment(startX - i, 0, startZ);
                }
            }
            
            addSegment(x, y, z) {
                const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const material = new THREE.MeshLambertMaterial({ color: this.color });
                const segment = new THREE.Mesh(geometry, material);
                segment.position.set(x, y, z);
                segment.castShadow = true;
                this.segments.push(segment);
                scene.add(segment);
            }
            
            move() {
                if (!gameRunning) return;
                
                // Get head position
                const head = this.segments[0];
                const newX = head.position.x + this.direction.x;
                const newY = head.position.y + this.direction.y;
                const newZ = head.position.z + this.direction.z;
                
                // Check bounds
                const halfBoard = CONFIG.BOARD_SIZE / 2 - 1;
                if (newX >= halfBoard || newX <= -halfBoard || 
                    newZ >= halfBoard || newZ <= -halfBoard ||
                    newY >= 10 || newY <= -1) {
                    this.die();
                    return;
                }
                
                // Check self collision
                for (let segment of this.segments) {
                    if (Math.abs(segment.position.x - newX) < 0.5 && 
                        Math.abs(segment.position.y - newY) < 0.5 && 
                        Math.abs(segment.position.z - newZ) < 0.5) {
                        this.die();
                        return;
                    }
                }
                
                // Check collision with other snakes
                for (let otherSnake of snakes) {
                    if (otherSnake === this) continue;
                    for (let segment of otherSnake.segments) {
                        if (Math.abs(segment.position.x - newX) < 0.5 && 
                            Math.abs(segment.position.y - newY) < 0.5 && 
                            Math.abs(segment.position.z - newZ) < 0.5) {
                            this.die();
                            return;
                        }
                    }
                }
                
                // Check food collision
                for (let i = foods.length - 1; i >= 0; i--) {
                    const food = foods[i];
                    if (Math.abs(food.position.x - newX) < 0.8 && 
                        Math.abs(food.position.y - newY) < 0.8 && 
                        Math.abs(food.position.z - newZ) < 0.8) {
                        this.eat(food, i);
                        break;
                    }
                }
                
                // Move snake
                if (this.growing) {
                    this.addSegment(newX, newY, newZ);
                    this.growing = false;
                } else {
                    // Move tail to head
                    const tail = this.segments.pop();
                    tail.position.set(newX, newY, newZ);
                    this.segments.unshift(tail);
                }
            }
            
            eat(food, foodIndex) {
                scene.remove(food);
                foods.splice(foodIndex, 1);
                this.growing = true;
                scores[this.playerId]++;
                updateScores();
                
                // Create new food
                if (foods.length < CONFIG.FOOD_COUNT) {
                    createFood();
                }
            }
            
            die() {
                gameRunning = false;
                showGameOver();
            }
            
            setDirection(x, y, z) {
                // Prevent moving backwards
                if (this.direction.x !== -x || this.direction.y !== -y || this.direction.z !== -z) {
                    this.direction = { x, y, z };
                }
            }
        }

        function createSnakes() {
            const startPositions = [
                { x: -10, z: -10 },
                { x: 10, z: 10 },
                { x: -10, z: 10 },
                { x: 10, z: -10 }
            ];
            
            for (let i = 0; i < CONFIG.PLAYERS; i++) {
                const snake = new Snake(
                    startPositions[i].x, 
                    startPositions[i].z, 
                    SNAKE_COLORS[i], 
                    i
                );
                snakes.push(snake);
            }
        }

        function createFood() {
            const geometry = new THREE.SphereGeometry(0.5, 8, 8);
            const material = new THREE.MeshLambertMaterial({ color: 0xff8844 });
            const food = new THREE.Mesh(geometry, material);
            
            // Random position
            const halfBoard = CONFIG.BOARD_SIZE / 2 - 2;
            food.position.set(
                Math.random() * (halfBoard * 2) - halfBoard,
                Math.random() * 8,
                Math.random() * (halfBoard * 2) - halfBoard
            );
            
            food.castShadow = true;
            foods.push(food);
            scene.add(food);
        }

        function setupControls() {
            document.addEventListener('keydown', (event) => {
                keys[event.code] = true;
                
                if (event.code === 'KeyR') {
                    restartGame();
                }
            });
            
            document.addEventListener('keyup', (event) => {
                keys[event.code] = false;
            });
        }

        function handleInput() {
            if (!gameRunning) return;
            
            // Player 1 (WASD + QE)
            if (keys['KeyW']) snakes[0].setDirection(0, 0, -1);
            if (keys['KeyS']) snakes[0].setDirection(0, 0, 1);
            if (keys['KeyA']) snakes[0].setDirection(-1, 0, 0);
            if (keys['KeyD']) snakes[0].setDirection(1, 0, 0);
            if (keys['KeyQ']) snakes[0].setDirection(0, -1, 0);
            if (keys['KeyE']) snakes[0].setDirection(0, 1, 0);
            
            // Player 2 (Arrow Keys + PgUp/PgDn)
            if (keys['ArrowUp']) snakes[1].setDirection(0, 0, -1);
            if (keys['ArrowDown']) snakes[1].setDirection(0, 0, 1);
            if (keys['ArrowLeft']) snakes[1].setDirection(-1, 0, 0);
            if (keys['ArrowRight']) snakes[1].setDirection(1, 0, 0);
            if (keys['PageUp']) snakes[1].setDirection(0, 1, 0);
            if (keys['PageDown']) snakes[1].setDirection(0, -1, 0);
            
            // Player 3 (IJKL + UO)
            if (keys['KeyI']) snakes[2].setDirection(0, 0, -1);
            if (keys['KeyK']) snakes[2].setDirection(0, 0, 1);
            if (keys['KeyJ']) snakes[2].setDirection(-1, 0, 0);
            if (keys['KeyL']) snakes[2].setDirection(1, 0, 0);
            if (keys['KeyU']) snakes[2].setDirection(0, 1, 0);
            if (keys['KeyO']) snakes[2].setDirection(0, -1, 0);
            
            // Player 4 (Numpad)
            if (keys['Numpad8']) snakes[3].setDirection(0, 0, -1);
            if (keys['Numpad2']) snakes[3].setDirection(0, 0, 1);
            if (keys['Numpad4']) snakes[3].setDirection(-1, 0, 0);
            if (keys['Numpad6']) snakes[3].setDirection(1, 0, 0);
            if (keys['Numpad7']) snakes[3].setDirection(0, 1, 0);
            if (keys['Numpad9']) snakes[3].setDirection(0, -1, 0);
        }

        function updateScores() {
            for (let i = 0; i < CONFIG.PLAYERS; i++) {
                document.getElementById(`score${i + 1}`).textContent = scores[i];
            }
        }

        function showGameOver() {
            const gameOverDiv = document.getElementById('gameOver');
            const gameOverText = document.getElementById('gameOverText');
            
            const maxScore = Math.max(...scores);
            const winners = scores.map((score, index) => score === maxScore ? index + 1 : null)
                                 .filter(player => player !== null);
            
            if (winners.length === 1) {
                gameOverText.textContent = `Player ${winners[0]} wins with ${maxScore} points!`;
            } else {
                gameOverText.textContent = `Tie game! Players ${winners.join(', ')} each scored ${maxScore} points!`;
            }
            
            gameOverDiv.style.display = 'block';
        }

        function restartGame() {
            // Clear existing game objects
            snakes.forEach(snake => {
                snake.segments.forEach(segment => scene.remove(segment));
            });
            foods.forEach(food => scene.remove(food));
            
            // Reset game state
            snakes = [];
            foods = [];
            scores = [0, 0, 0, 0];
            gameRunning = true;
            
            // Hide game over screen
            document.getElementById('gameOver').style.display = 'none';
            
            // Recreate game elements
            createSnakes();
            createFood();
            updateScores();
        }

        let lastTime = 0;
        function gameLoop(currentTime) {
            requestAnimationFrame(gameLoop);
            
            if (currentTime - lastTime > 200) { // Snake movement speed
                handleInput();
                
                if (gameRunning) {
                    snakes.forEach(snake => snake.move());
                }
                
                lastTime = currentTime;
            }
            
            // Rotate food
            foods.forEach(food => {
                food.rotation.y += 0.02;
            });
            
            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start the game
        init();
    </script>
</body>
</html>